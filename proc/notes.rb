#// # Proc
#//
#// Proc objects are blocks of code bound to local variables. Since it is 
#// bound, the block can be called in various contexts while retaining 
#// access to the object's variables.
def gen_times(factor)
  return Proc.new { |n| n * factor }
end

times3 = gen_times(3)
times5 = gen_times(5)

time3.call(12)                  #=> 36
times5.call(5)                  #=> 25
times3.call(times5.call(4))     #=> 60

#// ## Public Class Methods
#//
#// `new` method
#//     Proc.new {|..| block }  --> a_proc
#//     Proc.new  --> a_proc
#// Creates a proc object bound to the current context. Without a block, 
#// Proc::new can only be called within a method that has an attache block,
#// which is convreted to the proc object
def proc_from
  Proc.new
end

proc = proc_from { "hello" }

proc.call                    #=> "hello"

#// ## Public Instance Methods
#//
#// `arity` method
#//     proc.arity  --> fixnum
#// Returns the number of mandatory arguments proc takes. If the block takes
#// optional arguments it returns -n-1 (negative `n` minus 1). A proc with 
#// no argument declarations is equivlent to a block declaring { || }
proc {}.arity               #=> 0
proc { || }.arity           #=> 0
proc { |a| }.arity          #=> 1
proc { |a, b| }.arity       #=> 2
proc { |a, b, c| }.arity    #=> 3
proc { |*a| }               #=> -1
proc { |a, *b| }.arity      #=> -2
proc { |a, *b, c| }.arity   #=> -3
proc { x:, y:, z: 0}.arity  #=> 1
proc {|*a, x:, y:0|}.arity  #=> -2

proc { |x=0| }.arity        #=> 0
lambda { |x=0| }.arity      #=> -1
proc { |x=0, y| }.arity     #=> 1
lambda { |x=0, y| }.arity   #=> -2
proc { |x=0, y=0| }.arity   #=> 0
lambda {|x=0,y=0|}.arity    #=> -1
proc { |x, y=0| }.arity     #=> 1
lambda {|x, y=0|}.arity     #=> -2
proc {|(x, y), z=0|}.arity  #=> 1
lambda {|(x,y),z=0|}.arity  #=> -2
proc {|a, x:0, z:0|}.arity  #=> 1
lambda {|a,x:0,z:0|}.arity  #=> -2

#// `binding` method
#//     prc.binding  --> binding
#// Returns the binding associated with `prc` can be used as a second param
#// for Kernel#eval (which accepts Procs or bindings)
def fred(param)
  proc {}
end

b = fred(99)
eval("param", b.binding)    #=> 99

#// `curry` method
#//     prc.curry  --> a_proc
#//     prc.curry(arity)  --> a_proc
#// Returns a curried proc. Optional argument for arity, which determines 
#// the number of arguments. If sufficient arguments are passed through it
#// pushes these to the proc and returns the result
b = proc {|x, y, z| (x||0) + (y||0) + (z||0)}

p b.curry[1][2][3]          #=> 6
p b.curry[1, 2][3, 4]       #=> 6
p b.curry[1, 4][3, 4]       #=> 8
p b.curry(5)[1][2][3][4][5] #=> 6
p b.curry(5)[1, 2][3, 4][5] #=> 6
p b.curry(1)[1]             #=> 1

b = proc {|x,y,z,*w| (x||0)+(y||0)+(z||0)+w.inject(0,&:+)}

p b.curry[1][2][3]          #=> 6
p b.curry[1, 2][3, 4]       #=> 10
p b.curry(5)[1][2][3][4][5] #=> 15
p b.curry(5)[1, 2][3, 4][5] #=> 15
p b.curry(1)[1]             #=> 1

b = lambda {|x, y, z| (x||0) + (y||0) + (z||0)}

p b.curry[1][2][3]          #=> 6
p b.curry[1, 2][3, 4]       #=> wrong number of arguments (given 4, exptd 3)
p b.curry(5)                #=> wrong number of arguments (given 5, exptd 3)
p b.curry(1)                #=> wrong number of arguments (given 1, exptd 3)

b = lambda {|x, y, z, *w| (x||0)+(y||0)+(z||0)+ w.inject(0, &:+)}

p b.curry[1][2][3]          #=> 6
p b.curry[1, 2][3, 4]       #=> 10
p b.curry(5)[1][2][3][4][5] #=> 15
p b.curry(5)[1, 2][3, 4][5] #=> 15
p b.curry(1)                #=> wrong number of arguments (given 1, exptd 3)

b = proc { :foo }
p b.curry[]                 #=> :foo

#// `hash` method
#//     prc.hash  --> integer
#// Returns hash value corresponding to proc body
proc {}.hash                #=> -98950528503686819  // num is variable

a = proc {}
a.hash == proc {}.hash      #=> false

#// `inspect` method
#//     prc.inspect()  --> proc
#// Alias for `to_s` method
c = proc {|x, y, z| (x||0) + (y||0) + (z||0)}

c.inspect()                 #=> #<Proc:0x...>
c.inspect                   #=> #<Proc:0x...>

#// `lambda?` method
#//     prc.lambda?  --> true || false
#// Returns true if `proc`s argument handling is rigid (generally meaning
#// they were generated by `lambda`). Proc objects usually ignore extra
#// arguments, provide nil for missing arguments, and expands single 
#// argument arrays
proc {|a,b| [a,b]}.call(1,2,3)    #=> [1, 2]

proc {|a,b| [a,b]}.call(1)        #=> [1, nil]

proc {|a,b| [a,b]}.call([1,2])    #=> [1, 2]

lambda {|a,b| [a,b]}.call(1,2,3)  #=> ArgumentError
lambda {|a,b| [a,b]}.call(1)      #=> ArgumentError
lambda {|a,b| [a,b]}.call([1,2])  #=> ArgumentError

lambda {}.lambda?                 #=> true
proc {}.lambda?                   #=> false

Proc.new {}.lambda?               #=> false

lambda(&lambda {}).lambda?        #=> true
proc (&lambda {}).lambda?         #=> true
Proc.new(&lambda {}).lambda?      #=> true

lambda(&proc {}).lambda?          #=> false
proc (&proc {}).lambda?           #=> false
Proc.new(&proc {}).lambda?        #=> false

def n(&b) b.lambda? end
n {}                              #=> false

n(&lambda {})                     #=> true
n(&proc {})                       #=> false
n(&Proc.new {})                   #=> false

def m() end
method(:m).to_proc.lambda?        #=> true

n(&method(:m))                    #=> true
n(&method(:m),to_proc)            #=> true

class C
  define_method(:d) {}
end

C.new.d(1,2)                      #=> ArgumentError
C.new.method(:d).to_proc.lambda?  #=> true


class C
  def self.def2(name, &body)
    define_method(name, &body)
  end
  def2(:f) {}
end
C.new.f(1,2)                      #=> ArgumentError

#// `parameters` method
#//     prc.parameters  --> array
#// Returns an array of the parameters for `prc`
prc = lambda {|x, y=42, *other|}
prc.parameters             #=> [[:req, :x], [:opt, :y], [:rest, :other]]

#// `source_location` method
#//     prc.source_location  --> [String, Fixnum]
#// Returns Ruby source filename containing the proc or nil if proc is not
#// defined in Ruby
prc = lambda {|x, y=42, *other|}
prc.source_location        #=> ["(irb)", 24]  // only for my instance of irb

#// `to_proc` method
#//     prc.to_proc  --> proc
#// Part of protocol that converts objects to Proc objects. Instances of 
#// Proc class return themselves
proc {}.to_proc            #=> #<Proc:0x...>

#// `to_s` method
#//     prc.to_s  --> String
#// Returns unique identifier for the proc with an indication of where it 
#// was defined
proc {}.to_s               #=> #<Proc:0x...>

